{"headers":[{"key":"pos","value":true,"style":"boolean"}],"items":[{"key":"o","value":0,"style":"number","css":"o"},{"key":"x","value":0,"style":"number","css":"x"},{"key":"div","css":"div"},{"key":"pinch","css":"pinch_img"},{"key":"chance","css":"chance_img"},{"key":"star","css":"star_img"}],"priority":[{"key":"status","order":"desc","alter":["win",2,"lose",0,0]},{"key":"o","order":"desc"}],"actions":[{"name":"○","css":"action_o","button_css":"btn btn-primary btn-lg","keyArray":"k1","tweet":"o","enable0":"return (player.status == 'normal' && !header.playoff);","action0":"// ○を加算\nplayer.o++;\nsetMotion(player, 'o');\naddQCount(players, header, property);"},{"name":"×","css":"action_x","button_css":"btn btn-danger btn-lg","keyArray":"k2","tweet":"x","enable0":"return (player.status == 'normal' && !header.playoff);","action0":"// ×を加算\nplayer.x++;\n// 休み処理\nplayer.status = \"preabsent\";\nplayer.absent = players.filter(function(p) {\n  return p.status != \"win\" && p.status != \"lose\";\n}).length - 1;\n\nsetMotion(player, 'x');\naddQCount(players, header, property);"}],"global_actions":[{"name":"thru","button_css":"btn btn-default","group":"rule","keyboard":"Space","tweet":"thru","enable0":"return true;","action0":"addQCount(players, header, property);"},{"name":"pos","button_css":"btn btn-default","group":"rule","enable0":"return true;","action0":"header.pos = !header.pos;","keyArray":""}],"global_actions_repeat":[],"tweet":{"o":"${handleName}◯　→${o}◯ ${x}×","x":"${handleName}×　→${o}◯ ${x}× ${absent}休","thru":"スルー"},"judgement":"// 所定回数以上の×は失格\nplayers.filter(function(p) {\n  return p.status != \"win\" && p.status != \"lose\" && p.x >= property.losingPoint;\n}).map(function(p) {\n  lose(p, players, header, property);\n});\n\nfunction withoutWin(p) {\n  return p.status != \"win\";\n}\n\nvar maxPoint = Math.max.apply(null, players.filter(withoutWin).map(function(p) {\n  return p.o;\n}));\nvar minPoint = Math.min.apply(null, players.filter(withoutWin).map(function(p) {\n  return p.o;\n}));\nvar changedPlayer = [];\n\nvar nowGap = 0;\nvar gapPtsArray = [];\n\ngapFor: for (var pts = maxPoint; pts >= minPoint; pts--) {\n  if (players.filter(function(p) {\n      return p.o == pts && p.status != \"win\";\n    }).length > 0) {\n    nowGap = 0;\n  } else {\n    nowGap++;\n    if (nowGap >= property.gap - 1) {\n      gapPtsArray.push(pts);\n      //break gapFor;\n    }\n  }\n}\n\nangular.forEach(gapPtsArray, function(gapPts) {\n  // 既に勝抜している人数＋ラインより上の人数\n  console.log(gapPts, players.filter(function(p) {\n    return p.status == \"win\";\n  }).length, players.filter(function(p) {\n    return p.o > gapPts && p.status != \"win\" && p.status != \"lose\";\n  }).length);\n  \n  var nextWinnerCount = players.filter(function(p) {\n    return p.status == \"win\";\n  }).length + players.filter(function(p) {\n    return p.o > gapPts && p.status != \"win\" && p.status != \"lose\";\n  }).length;\n\n  // 勝抜人数以下の場合、ラインより上のプレイヤーは勝抜\n  if (nextWinnerCount <= property.maxRankDisplay) {\n    players.filter(function(p) {\n      return p.o > gapPts && p.status != \"win\" && p.status != \"lose\";\n    }).map(function(p) {\n      win(p, players, header, property);\n      changedPlayer.push(p);\n    });\n  }\n  // 勝抜人数以上の場合、ラインより下のプレイヤーは失格\n  if (nextWinnerCount >= property.maxRankDisplay) {\n    players.filter(function(p) {\n      return p.o < gapPts && p.status != \"win\" && p.status != \"lose\";\n    }).map(function(p) {\n      lose(p, players, header, property);\n      changedPlayer.push(p);\n    });\n  }\n\n});\n\nreturn changedPlayer;","calc":"function getPlayer(ps, p) {\n  var pp = ps.filter(function(np) {\n    return np.entryNo == p.entryNo\n  });\n  if (pp.length > 0) {\n    return pp[0];\n  } else {\n    return undefined;\n  }\n}\n\n// div\nvar prevPlayer;\nif (header.pos) {\n  players.map(function(p) {\n    p.div = 0;\n  });\n} else {\n  players.slice().sort(function(a, b) {\n    return a.priority - b.priority;\n  }).filter(function(p) {\n    return players.filter(function(pp) {\n      return pp.priority >= p.priority && pp.status != \"win\" && pp.status != \"lose\"\n    }).length > 0;\n  }).map(function(p) {\n    if (prevPlayer) {\n      if (prevPlayer.status != \"win\") {\n        prevPlayer.div = prevPlayer.o - p.o;\n      } else {\n        prevPlayer.div = 0;\n      }\n    }\n    prevPlayer = p;\n    p.div = 0;\n  });\n}\n\n// pinch, chance, star\nplayers.map(function(p) {\n  p.pinch = false;\n  p.chance = false;\n  p.star = false;\n});\n\nplayers.filter(function(p) {\n  return p.status == \"normal\";\n}).map(function(p) {\n  var nextPlayers = angular.copy(players);\n  getPlayer(nextPlayers, p).o++;\n  var judge = judgement(nextPlayers, angular.copy(header), property);\n  if (judge.length > 0) {\n    p.star = true;\n    judge.map(function(np) {\n      if (np.status == \"win\") {\n        getPlayer(players, np).chance = true;\n      } else if (np.status == \"lose\") {\n        getPlayer(players, np).pinch = true;\n      }\n    })\n  }\n});\n\n\nangular.forEach(players, function(player, index) {\n\n  // キーボード入力時の配列の紐付け ローリング等の特殊形式でない場合はこのままでOK\\\n  player.keyIndex = player.position;\n  if (header.pos) {\n    player.line = \"line1\";\n  } else {\n    player.line = \"line2\";\n  }\n});","lines":[{"key":"line1","xType":true,"yType":false,"invisible":false,"zoom":1,"left":0,"right":1,"top":0,"y":0.5,"orderBy":"position"},{"key":"line2","orderBy":"priority","xType":true,"yType":false,"invisible":false,"zoom":1,"left":0,"right":1,"y":0.5}]}